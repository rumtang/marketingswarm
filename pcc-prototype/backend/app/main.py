from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Depends, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordRequestForm
from contextlib import asynccontextmanager
import asyncio
import json
from typing import List, Dict, Any
from datetime import datetime, timedelta
import logging

from database.client import DatabaseClient
from messaging.consumer import HL7Consumer
from narrative_engine import NarrativeEngine, get_narrative_engine
from agents.capacity_predictor import CapacityPredictor
from agents.discharge_accelerator import DischargeAccelerator
from agents.concierge_chat import ConciergeChat
from auth import (
    Token, authenticate_user, create_access_token, get_current_active_user,
    fake_users_db, ACCESS_TOKEN_EXPIRE_MINUTES, User
)
from cache import api_cache, cached_api_response

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Global state
connected_clients: List[WebSocket] = []
db_client = DatabaseClient()
narrative_engine: NarrativeEngine = None

# Narrative-aware agents
capacity_predictor = None
discharge_accelerator = None
concierge_chat = None


async def broadcast_update(message: Dict[str, Any]):
    """Broadcast updates to all connected WebSocket clients"""
    disconnected = []
    for client in connected_clients:
        try:
            await client.send_json(message)
        except Exception:
            disconnected.append(client)
    
    # Clean up disconnected clients
    for client in disconnected:
        connected_clients.remove(client)


async def process_narrative_events():
    """Process events from the narrative engine"""
    consumer = HL7Consumer()
    
    while True:
        try:
            # Get events from Kafka (generated by narrative engine)
            events = await asyncio.get_event_loop().run_in_executor(
                None, consumer.consume_events
            )
            
            # Process each event
            for event in events:
                if event:
                    logger.info(f"Processing narrative event: {event.get('event_type')}")
                    
                    # Process the event - just get current bed status
                    # The narrative engine already stored the event when it generated it
                    if narrative_engine and narrative_engine.db:
                        bed_status = await narrative_engine.db.get_bed_status()
                    else:
                        bed_status = []
                
                    # Get narrative-aware predictions
                    if capacity_predictor:
                        prediction = await capacity_predictor.predict_capacity(bed_status)
                    else:
                        prediction = None
                
                    # Check for narrative-driven discharge barriers
                    barriers = []
                    if event.get('patient_id') and discharge_accelerator:
                        patient_data = await narrative_engine.get_patient_data(event['patient_id'])
                        barriers = await discharge_accelerator.identify_barriers({
                            'patient_id': event['patient_id'],
                            'narrative_context': patient_data
                        })
                
                    # Generate AI insights if event triggers them
                    ai_insight = None
                    if event.get('triggers_insight'):
                        ai_insight = await narrative_engine.generate_agent_insight(
                            'system',
                            {'event': event, 'bed_status': bed_status}
                        )
                
                    # Broadcast update with narrative context
                    update = {
                        "type": "bed_update",
                        "data": {
                            "event": event,
                            "bed_status": bed_status,
                            "prediction": prediction,
                            "barriers": barriers,
                            "narrative_context": event.get('narrative_context', {}),
                            "ai_insight": ai_insight
                        },
                        "timestamp": datetime.now().isoformat()
                    }
                    
                    await broadcast_update(update)
                
                    # Send narrative insights as separate alerts
                    if ai_insight:
                        insight_alert = {
                            "type": "narrative_insight",
                            "data": {
                                "message": ai_insight,
                                "significance": event.get('narrative_significance', ''),
                                "bed_id": event.get('bed_id'),
                                "recommendation": "Review patient narrative for context"
                            },
                            "timestamp": datetime.now().isoformat()
                        }
                        await broadcast_update(insight_alert)
                
        except Exception as e:
            logger.error(f"Error processing narrative event: {e}")
            await asyncio.sleep(1)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manage application lifecycle"""
    global narrative_engine, capacity_predictor, discharge_accelerator, concierge_chat
    
    # Initialize narrative engine (but don't start it yet)
    narrative_engine = await get_narrative_engine()
    
    # Initialize narrative-aware agents
    capacity_predictor = CapacityPredictor(narrative_engine)
    discharge_accelerator = DischargeAccelerator(narrative_engine)
    concierge_chat = ConciergeChat(narrative_engine)
    
    # Start the narrative engine in the background after app startup
    async def start_narrative_engine():
        await asyncio.sleep(2)  # Give the app time to start
        logger.info("Starting narrative engine...")
        await narrative_engine.start()
        logger.info("Narrative engine started successfully")
    
    # Start background tasks
    engine_task = asyncio.create_task(start_narrative_engine())
    process_task = asyncio.create_task(process_narrative_events())
    
    # Import and start cache cleanup task
    from cache import cache_cleanup_task
    cache_task = asyncio.create_task(cache_cleanup_task())
    
    yield
    
    # Cleanup
    engine_task.cancel()
    process_task.cancel()
    cache_task.cancel()
    await narrative_engine.stop()


app = FastAPI(
    title="Patient Command Center - Narrative Edition",
    version="0.2.0-alpha",
    lifespan=lifespan
)

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/")
async def root():
    return {"message": "Patient Command Center API", "status": "operational"}


@app.get("/health")
async def health_check():
    """Health check endpoint for monitoring"""
    health_status = {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "services": {
            "database": "unknown",
            "kafka": "unknown"
        }
    }
    
    try:
        # Check database (narrative engine manages the database)
        if narrative_engine and narrative_engine.db and narrative_engine.db.conn:
            db_health = "healthy"
        else:
            db_health = "starting"
        
        # Check narrative engine
        if narrative_engine:
            narrative_health = "healthy" if narrative_engine.running else "starting"
        else:
            narrative_health = "initializing"
        
        health_status["services"]["database"] = db_health
        health_status["services"]["narrative_engine"] = narrative_health
        health_status["services"]["kafka"] = "healthy"  # Assumed if we're running
        
        if db_health == "starting" or narrative_health in ["starting", "initializing"]:
            health_status["status"] = "starting"
            
    except Exception as e:
        health_status["status"] = "unhealthy"
        health_status["error"] = str(e)
        logger.error(f"Health check failed: {e}")
    
    return health_status


@app.post("/token", response_model=Token)
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    """Login endpoint to get access token"""
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}


@app.get("/users/me", response_model=User)
async def read_users_me(current_user: User = Depends(get_current_active_user)):
    """Get current user information"""
    return current_user


@app.get("/api/bed-status")
async def get_bed_status(current_user: User = Depends(get_current_active_user)):
    """Get current bed status from narrative context with optimized batch loading"""
    if not narrative_engine or not narrative_engine.db:
        raise HTTPException(status_code=503, detail="Service starting up")
    
    # Check API cache first
    cache_key = f"bed-status:{current_user.username}"
    cached_response = await api_cache.get_response("/api/bed-status", {"user": current_user.username})
    if cached_response:
        return cached_response
    
    # Get bed status from database
    beds = await narrative_engine.db.get_bed_status()
    
    # Collect all patient IDs that need enrichment
    patient_ids = [bed['patient_id'] for bed in beds if bed.get('patient_id')]
    
    # Batch load all patient data
    if patient_ids:
        all_patients = await narrative_engine.get_all_patients_batch()
        
        # Enrich beds with patient data from batch
        for bed in beds:
            patient_id = bed.get('patient_id')
            if patient_id and patient_id in all_patients:
                patient_data = all_patients[patient_id]
                bed['patient_name'] = patient_data.get('name', 'Unknown')
                bed['diagnosis'] = patient_data.get('diagnosis', 'Unknown')
                bed['admission_time'] = patient_data.get('admission_time')
                bed['discharge_barriers'] = patient_data.get('discharge_barriers', [])
                bed['emotional_state'] = patient_data.get('emotional_state')
                bed['narrative_arc'] = patient_data.get('narrative_arc')
    
    response = {"beds": beds}
    
    # Cache the response for 30 seconds
    await api_cache.set_response("/api/bed-status", response, {"user": current_user.username}, ttl=30)
    
    return response


@app.get("/api/capacity-forecast")
async def get_capacity_forecast(current_user: User = Depends(get_current_active_user)):
    """Get narrative-aware capacity forecast"""
    if not narrative_engine or not narrative_engine.db:
        raise HTTPException(status_code=503, detail="Service starting up")
    bed_status = await narrative_engine.db.get_bed_status()
    
    # Add narrative context
    context = {
        "narrative_phase": narrative_engine.narrative_phase,
        "hospital_context": narrative_engine.hospital_context,
        "recent_events": len(narrative_engine.event_history)
    }
    
    forecast = await capacity_predictor.predict_capacity(bed_status, context)
    return {"forecast": forecast}


@app.get("/api/patient/{patient_id}")
async def get_patient_narrative(
    patient_id: str,
    current_user: User = Depends(get_current_active_user)
):
    """Get full patient narrative"""
    patient_data = await narrative_engine.get_patient_data(patient_id)
    return {"patient": patient_data}


@app.post("/api/chat")
async def chat_with_concierge(
    query: Dict[str, str],
    current_user: User = Depends(get_current_active_user)
):
    """Chat with narrative-aware concierge"""
    # Add narrative context to query
    enriched_query = {
        "text": query.get("message", ""),
        "context": {
            "narrative_phase": narrative_engine.narrative_phase,
            "hospital_state": narrative_engine.hospital_context,
            "session_summary": await narrative_engine.get_session_summary()
        }
    }
    
    response = await concierge_chat.process_query(enriched_query)
    return {"response": response}


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket endpoint for real-time updates"""
    await websocket.accept()
    connected_clients.append(websocket)
    
    try:
        # Send initial status with narrative context
        if narrative_engine and narrative_engine.db:
            beds = await narrative_engine.db.get_bed_status()
        else:
            beds = []
        
        # Enrich with narrative data
        for bed in beds:
            if bed.get('patient_id'):
                patient_data = await narrative_engine.get_patient_data(bed['patient_id'])
                bed['patient_name'] = patient_data.get('name', 'Unknown')
                bed['diagnosis'] = patient_data.get('diagnosis', 'Unknown')
                bed['emotional_state'] = patient_data.get('emotional_state')
        
        initial_status = {
            "type": "initial_status",
            "data": {
                "bed_status": beds,
                "narrative_context": {
                    "session_id": narrative_engine.session_id,
                    "narrative_phase": narrative_engine.narrative_phase,
                    "hospital_context": narrative_engine.hospital_context
                }
            },
            "timestamp": datetime.now().isoformat()
        }
        
        await websocket.send_json(initial_status)
        
        # Keep connection alive and handle pings
        while True:
            message = await websocket.receive_text()
            if message == "ping":
                await websocket.send_text("pong")
            
    except WebSocketDisconnect:
        connected_clients.remove(websocket)
        logger.info("Client disconnected")
    except Exception as e:
        logger.error(f"WebSocket error: {e}")
        if websocket in connected_clients:
            connected_clients.remove(websocket)


@app.get("/api/alerts")
async def get_alerts(current_user: User = Depends(get_current_active_user)):
    """Get recent narrative-driven alerts"""
    # Generate contextual alerts based on narrative state
    alerts = []
    
    # Check recent events for alert-worthy items
    recent_events = narrative_engine.event_history[-10:] if narrative_engine else []
    
    for event in recent_events:
        if event.get('triggers_insight') or event.get('narrative_significance'):
            alert = {
                "id": f"alert-{event.get('timestamp', '')}",
                "type": event.get('event_type', 'narrative_event'),
                "severity": "high" if event.get('triggers_insight') else "medium",
                "message": event.get('description', 'Narrative event occurred'),
                "recommendation": event.get('narrative_significance', ''),
                "timestamp": event.get('timestamp', datetime.now().isoformat())
            }
            alerts.append(alert)
    
    return {"alerts": alerts}